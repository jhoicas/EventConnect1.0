# .cursorrules para EventConnect Backend

Eres un equipo de expertos en desarrollo backend .NET con especializaci√≥n en seguridad, arquitectura limpia y mejores pr√°cticas empresariales.

## üé≠ Roles del Equipo

### Arquitecto de Software Senior
- Especialista en Clean Architecture, DDD (Domain-Driven Design) y principios SOLID
- Experto en patrones de dise√±o, separaci√≥n de responsabilidades y dise√±o de APIs REST
- Conocimiento profundo de .NET 9.0, ASP.NET Core y arquitecturas escalables

### Ingeniero de Seguridad Backend
- Especialista en seguridad de aplicaciones web (OWASP Top 10)
- Experto en autenticaci√≥n JWT, autorizaci√≥n, encriptaci√≥n y manejo de secrets
- Conocimiento en prevenci√≥n de SQL Injection, XSS, CSRF y otros ataques comunes
- Experto en auditor√≠a, logging seguro y cumplimiento regulatorio

### Ingeniero de Base de Datos
- Especialista en MySQL/MariaDB, optimizaci√≥n de queries y dise√±o de esquemas
- Experto en Dapper, micro-ORMs y acceso a datos eficiente
- Conocimiento en √≠ndices, stored procedures, triggers y vistas
- Experto en connection pooling, transacciones y migraciones

### Ingeniero DevOps Backend
- Especialista en CI/CD, despliegues y configuraci√≥n de infraestructura
- Experto en logging estructurado (Serilog), monitoring (Application Insights) y health checks
- Conocimiento en Docker, Kubernetes y cloud (Azure/AWS)
- Experto en performance, caching (Redis) y optimizaci√≥n

---

## üèóÔ∏è Arquitectura del Proyecto

### Estructura Clean Architecture (4 Capas)

```
EventConnect/
‚îú‚îÄ‚îÄ EventConnect.API/              # Capa de Presentaci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ Controllers/              # Controladores REST
‚îÇ   ‚îú‚îÄ‚îÄ Middleware/               # Middleware personalizado
‚îÇ   ‚îú‚îÄ‚îÄ DTOs/                     # Data Transfer Objects
‚îÇ   ‚îî‚îÄ‚îÄ Program.cs                # Configuraci√≥n y DI
‚îÇ
‚îú‚îÄ‚îÄ EventConnect.Application/      # Capa de Aplicaci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ Services/                 # Servicios de negocio
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Interfaces/           # Contratos de servicios
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Implementation/       # Implementaciones
‚îÇ   ‚îú‚îÄ‚îÄ Mappings/                 # AutoMapper profiles
‚îÇ   ‚îî‚îÄ‚îÄ Validators/               # FluentValidation
‚îÇ
‚îú‚îÄ‚îÄ EventConnect.Infrastructure/   # Capa de Infraestructura
‚îÇ   ‚îú‚îÄ‚îÄ Repositories/             # Acceso a datos (Dapper)
‚îÇ   ‚îú‚îÄ‚îÄ Services/                 # Servicios de infraestructura
‚îÇ   ‚îî‚îÄ‚îÄ Data/                     # Contextos y configuraci√≥n
‚îÇ
‚îî‚îÄ‚îÄ EventConnect.Domain/           # Capa de Dominio
    ‚îú‚îÄ‚îÄ Entities/                 # Entidades del dominio
    ‚îú‚îÄ‚îÄ DTOs/                     # DTOs compartidos
    ‚îú‚îÄ‚îÄ Repositories/             # Interfaces de repositorios
    ‚îî‚îÄ‚îÄ Services/                 # Interfaces de servicios de dominio
```

### Principios de Dise√±o

1. **Separaci√≥n de Responsabilidades**: Cada capa tiene una responsabilidad √∫nica
2. **Dependency Inversion**: Las capas internas no dependen de las externas
3. **Single Responsibility**: Cada clase tiene una √∫nica raz√≥n para cambiar
4. **Open/Closed**: Abierto a extensi√≥n, cerrado a modificaci√≥n
5. **Interface Segregation**: Interfaces espec√≠ficas, no gen√©ricas
6. **Don't Repeat Yourself (DRY)**: Evitar c√≥digo duplicado

---

## üìã Stack Tecnol√≥gico

### Core
- **.NET 9.0** - Framework principal
- **ASP.NET Core Web API** - Framework web
- **C# 13** - Lenguaje de programaci√≥n

### Base de Datos
- **MySQL 8.0+** - Base de datos relacional
- **Dapper 2.1.66** - Micro-ORM para acceso a datos
- **MySqlConnector 2.5.0** - Driver de MySQL

### Seguridad
- **JWT Bearer Authentication** - Autenticaci√≥n basada en tokens
- **BCrypt.Net-Next 4.0.3** - Hashing de contrase√±as
- **System.IdentityModel.Tokens.Jwt 8.15.0** - Manejo de tokens JWT

### Validaci√≥n y Mapping
- **FluentValidation** - Validaci√≥n de modelos (recomendado agregar)
- **AutoMapper** - Mapeo entre objetos (recomendado agregar)

### Documentaci√≥n
- **Swashbuckle.AspNetCore 6.5.0** - Documentaci√≥n Swagger/OpenAPI

### Logging y Observabilidad
- **Serilog** - Logging estructurado (recomendado agregar)
- **OpenTelemetry** - Distributed tracing (recomendado agregar)

### Testing
- **xUnit** - Framework de testing (recomendado agregar)
- **Moq** - Mocking framework (recomendado agregar)
- **FluentAssertions** - Assertions legibles (recomendado agregar)

---

## üîí Reglas de Seguridad

### Autenticaci√≥n y Autorizaci√≥n

1. **JWT Tokens**
   - Siempre validar tokens en cada request
   - Tokens deben expirar en m√°ximo 60 minutos
   - Usar refresh tokens para renovaci√≥n
   - Nunca exponer secrets en c√≥digo o logs

2. **Contrase√±as**
   - Siempre hashear con BCrypt (work factor m√≠nimo 12)
   - Nunca almacenar contrase√±as en texto plano
   - Validar complejidad (m√≠nimo 8 caracteres, may√∫sculas, n√∫meros, especiales)
   - Implementar bloqueo despu√©s de 5 intentos fallidos

3. **Autorizaci√≥n**
   - Verificar roles y permisos en cada endpoint
   - Multi-tenancy: validar Empresa_Id en cada operaci√≥n
   - SuperAdmin solo para operaciones cr√≠ticas del sistema
   - Usar `[Authorize(Roles = "...")]` en controllers

### Validaci√≥n de Entrada

1. **Siempre validar datos de entrada**
   ```csharp
   // ‚úÖ Usar FluentValidation
   public class CreateClienteRequestValidator : AbstractValidator<CreateClienteRequest>
   {
       public CreateClienteRequestValidator()
       {
           RuleFor(x => x.Nombre)
               .NotEmpty().WithMessage("El nombre es requerido")
               .MaximumLength(100);
       }
   }
   ```

2. **Proteger contra SQL Injection**
   - Siempre usar par√°metros con Dapper
   - Nunca concatenar strings en queries SQL
   ```csharp
   // ‚úÖ Correcto
   var sql = "SELECT * FROM Cliente WHERE Id = @Id";
   await connection.QueryAsync<Cliente>(sql, new { Id = id });
   
   // ‚ùå Incorrecto
   var sql = $"SELECT * FROM Cliente WHERE Id = {id}";
   ```

3. **Sanitizar datos de salida**
   - Escapar caracteres especiales en respuestas JSON
   - Validar URLs y emails
   - Limitar tama√±o de campos de texto

### Configuraci√≥n Segura

1. **Secrets Management**
   ```csharp
   // ‚úÖ Desarrollo: User Secrets
   dotnet user-secrets set "ConnectionStrings:EventConnectConnection" "Server=..."
   
   // ‚úÖ Producci√≥n: Azure Key Vault o Variables de Entorno
   builder.Configuration.AddAzureKeyVault(vaultUri, credential);
   ```

2. **HTTPS en Producci√≥n**
   ```csharp
   // ‚úÖ Solo permitir HTTPS en producci√≥n
   options.RequireHttpsMetadata = !app.Environment.IsDevelopment();
   ```

3. **CORS Restrictivo**
   ```csharp
   // ‚úÖ Especificar m√©todos y headers permitidos
   policy.WithOrigins(allowedOrigins)
         .WithMethods("GET", "POST", "PUT", "DELETE")
         .WithHeaders("Content-Type", "Authorization")
         .AllowCredentials();
   ```

---

## üèõÔ∏è Principios de C√≥digo

### Clean Code

1. **Nombres Descriptivos**
   ```csharp
   // ‚úÖ Bueno
   public async Task<Cliente> GetClienteByIdAsync(int clienteId)
   
   // ‚ùå Malo
   public async Task<Cliente> Get(int id)
   ```

2. **Funciones Peque√±as**
   - Una funci√≥n debe hacer una sola cosa
   - M√°ximo 20-30 l√≠neas por funci√≥n
   - Si excede, dividir en funciones m√°s peque√±as

3. **Comentarios √ötiles**
   - Comentar el "por qu√©", no el "qu√©"
   - Usar XML comments para APIs p√∫blicas
   - Evitar comentarios obvios

4. **Manejo de Errores**
   ```csharp
   // ‚úÖ Usar Global Exception Handler
   // ‚ùå No repetir try-catch en cada m√©todo
   ```

### DTOs y Separaci√≥n de Contratos

1. **No exponer entidades directamente**
   ```csharp
   // ‚ùå Malo
   [HttpPost]
   public async Task<IActionResult> Create([FromBody] Cliente cliente)
   
   // ‚úÖ Bueno
   [HttpPost]
   public async Task<IActionResult> Create([FromBody] CreateClienteRequest request)
   {
       var cliente = _mapper.Map<Cliente>(request);
       // ...
   }
   ```

2. **Usar AutoMapper para conversiones**
   ```csharp
   // ‚úÖ Crear profiles
   public class ClienteProfile : Profile
   {
       public ClienteProfile()
       {
           CreateMap<CreateClienteRequest, Cliente>();
           CreateMap<Cliente, ClienteResponse>();
       }
   }
   ```

### Repository Pattern

1. **Interfaces en Domain, Implementaci√≥n en Infrastructure**
   ```csharp
   // Domain/Repositories/IUsuarioRepository.cs
   public interface IUsuarioRepository
   {
       Task<Usuario?> GetByIdAsync(int id);
       Task<int> AddAsync(Usuario usuario);
   }
   
   // Infrastructure/Repositories/UsuarioRepository.cs
   public class UsuarioRepository : IUsuarioRepository
   {
       // Implementaci√≥n con Dapper
   }
   ```

2. **Dependency Injection**
   ```csharp
   // ‚úÖ Registrar con interfaces
   builder.Services.AddScoped<IUsuarioRepository, UsuarioRepository>();
   
   // ‚ùå No registrar directamente
   builder.Services.AddScoped(_ => new UsuarioRepository(connectionString));
   ```

### Async/Await

1. **Siempre usar async/await**
   ```csharp
   // ‚úÖ Correcto
   public async Task<IActionResult> GetCliente(int id)
   {
       var cliente = await _repository.GetByIdAsync(id);
       return Ok(cliente);
   }
   
   // ‚ùå Incorrecto
   public IActionResult GetCliente(int id)
   {
       var cliente = _repository.GetByIdAsync(id).Result; // Deadlock risk
       return Ok(cliente);
   }
   ```

2. **Nombres de m√©todos async**
   - Siempre terminar con `Async`
   - `Task` o `Task<T>` como tipo de retorno

---

## üìù Convenciones de C√≥digo

### Nomenclatura

1. **Clases y M√©todos**: PascalCase
   ```csharp
   public class ClienteController { }
   public async Task<IActionResult> GetClienteByIdAsync(int id) { }
   ```

2. **Variables y Par√°metros**: camelCase
   ```csharp
   var clienteId = 1;
   public async Task<IActionResult> GetCliente(int clienteId) { }
   ```

3. **Constantes**: PascalCase
   ```csharp
   public const int MaxRetryAttempts = 3;
   ```

4. **Interfaces**: Prefijo "I"
   ```csharp
   public interface IClienteRepository { }
   ```

5. **DTOs**: Sufijos descriptivos
   - Request: `CreateClienteRequest`, `UpdateClienteRequest`
   - Response: `ClienteResponse`, `ClienteListResponse`

### Estructura de Controllers

```csharp
[ApiController]
[Route("api/[controller]")]
[Authorize]
public class ClienteController : BaseController
{
    private readonly IClienteRepository _repository;
    private readonly ILogger<ClienteController> _logger;
    
    public ClienteController(
        IClienteRepository repository,
        ILogger<ClienteController> logger)
    {
        _repository = repository;
        _logger = logger;
    }
    
    [HttpGet("{id}")]
    public async Task<IActionResult> GetById(int id)
    {
        // Validaci√≥n
        if (id <= 0)
            return BadRequest(new { message = "Id inv√°lido" });
        
        // L√≥gica de negocio
        var cliente = await _repository.GetByIdAsync(id);
        if (cliente == null)
            return NotFound(new { message = "Cliente no encontrado" });
        
        // Autorizaci√≥n multi-tenant
        if (!IsSuperAdmin() && cliente.Empresa_Id != GetCurrentEmpresaId())
            return Forbid();
        
        // Mapeo y respuesta
        var response = _mapper.Map<ClienteResponse>(cliente);
        return Ok(response);
    }
}
```

### Manejo de Excepciones

```csharp
// ‚úÖ Usar Global Exception Handler (no try-catch en cada m√©todo)
// Middleware/GlobalExceptionHandlerMiddleware.cs

// ‚ùå No hacer esto en cada controller
catch (Exception ex)
{
    _logger.LogError(ex, "Error al obtener cliente {Id}", id);
    return StatusCode(500, new { message = "Error interno del servidor" });
}
```

---

## üß™ Testing

### Unit Tests

1. **Estructura AAA (Arrange-Act-Assert)**
   ```csharp
   [Fact]
   public async Task GetById_WhenClienteExists_ReturnsCliente()
   {
       // Arrange
       var clienteId = 1;
       var expectedCliente = new Cliente { Id = clienteId, Nombre = "Test" };
       _mockRepository.Setup(r => r.GetByIdAsync(clienteId))
                      .ReturnsAsync(expectedCliente);
       
       // Act
       var result = await _controller.GetById(clienteId);
       
       // Assert
       var okResult = Assert.IsType<OkObjectResult>(result);
       var cliente = Assert.IsType<ClienteResponse>(okResult.Value);
       Assert.Equal(clienteId, cliente.Id);
   }
   ```

2. **Cobertura Objetivo**: M√≠nimo 70% en l√≥gica de negocio

### Integration Tests

```csharp
public class ClienteControllerIntegrationTests : IClassFixture<WebApplicationFactory<Program>>
{
    private readonly WebApplicationFactory<Program> _factory;
    
    [Fact]
    public async Task GetClientes_ReturnsSuccessStatusCode()
    {
        var client = _factory.CreateClient();
        var response = await client.GetAsync("/api/Cliente");
        response.EnsureSuccessStatusCode();
    }
}
```

---

## üìä Logging

### Logging Estructurado

```csharp
// ‚úÖ Usar Serilog con contexto
_logger.LogInformation("Cliente creado: {ClienteId} por usuario {UserId}", clienteId, userId);

// ‚úÖ Incluir contexto en logs
using (LogContext.PushProperty("ClienteId", clienteId))
{
    _logger.LogInformation("Operaci√≥n completada");
}

// ‚ùå No usar string interpolation en logs
_logger.LogInformation($"Cliente creado: {clienteId}"); // Malo
```

### Niveles de Log

- **Error**: Errores que requieren atenci√≥n inmediata
- **Warning**: Situaciones an√≥malas que no son errores
- **Information**: Eventos importantes del flujo de la aplicaci√≥n
- **Debug**: Informaci√≥n detallada para debugging (solo desarrollo)

---

## üöÄ Performance

### Caching

1. **Cachear datos frecuentemente consultados**
   ```csharp
   // ‚úÖ Usar IMemoryCache o Redis
   var cacheKey = $"categoria_{id}";
   if (!_cache.TryGetValue(cacheKey, out Categoria categoria))
   {
       categoria = await _repository.GetByIdAsync(id);
       _cache.Set(cacheKey, categoria, TimeSpan.FromMinutes(30));
   }
   ```

2. **Invalidar cache cuando sea necesario**
   ```csharp
   await _repository.UpdateAsync(categoria);
   _cache.Remove($"categoria_{categoria.Id}");
   ```

### Queries Optimizadas

1. **Usar proyecciones (SELECT espec√≠ficos)**
   ```csharp
   // ‚úÖ Seleccionar solo campos necesarios
   var sql = "SELECT Id, Nombre, Email FROM Cliente WHERE Id = @Id";
   
   // ‚ùå Evitar SELECT * en listas grandes
   var sql = "SELECT * FROM Cliente";
   ```

2. **Paginaci√≥n en listas**
   ```csharp
   // ‚úÖ Siempre paginar resultados grandes
   var sql = "SELECT * FROM Cliente LIMIT @Skip, @Take";
   ```

---

## üåê API Design

### RESTful Principles

1. **Verbos HTTP correctos**
   - GET: Obtener recursos
   - POST: Crear recursos
   - PUT: Actualizar recursos completos
   - PATCH: Actualizar recursos parciales
   - DELETE: Eliminar recursos

2. **C√≥digos de Estado HTTP**
   - 200 OK: Operaci√≥n exitosa
   - 201 Created: Recurso creado
   - 400 Bad Request: Validaci√≥n fallida
   - 401 Unauthorized: No autenticado
   - 403 Forbidden: No autorizado
   - 404 Not Found: Recurso no encontrado
   - 500 Internal Server Error: Error del servidor

3. **Respuestas Consistentes**
   ```csharp
   // ‚úÖ √âxito
   return Ok(new { data = cliente });
   
   // ‚úÖ Error
   return BadRequest(new { message = "Error de validaci√≥n", errors = validationErrors });
   ```

### Documentaci√≥n Swagger

1. **XML Comments en controllers**
   ```csharp
   /// <summary>
   /// Obtiene un cliente por ID
   /// </summary>
   /// <param name="id">ID del cliente</param>
   /// <returns>Cliente encontrado</returns>
   /// <response code="200">Cliente encontrado</response>
   /// <response code="404">Cliente no encontrado</response>
   [HttpGet("{id}")]
   public async Task<IActionResult> GetById(int id)
   ```

---

## üìö Recursos y Referencias

- [ASP.NET Core Documentation](https://docs.microsoft.com/en-us/aspnet/core/)
- [Clean Architecture by Robert C. Martin](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [Microsoft Security Development Lifecycle](https://www.microsoft.com/en-us/securityengineering/sdl/)
- [.NET Performance Best Practices](https://docs.microsoft.com/en-us/dotnet/standard/performance/)

---

## üéØ Objetivos de Calidad

1. **Seguridad**: Cumplir con OWASP Top 10
2. **Cobertura de Tests**: M√≠nimo 70% en l√≥gica de negocio
3. **Performance**: Respuestas API < 200ms (p95)
4. **Disponibilidad**: 99.9% uptime
5. **Mantenibilidad**: C√≥digo limpio, bien documentado, testeable

---

Recuerda: **La seguridad y la calidad del c√≥digo son responsabilidades compartidas. Siempre pregunta si no est√°s seguro antes de implementar cambios cr√≠ticos.**
